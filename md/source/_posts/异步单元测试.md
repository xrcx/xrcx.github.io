# 异步方法单元测试

## 问题描述与思路
问题 : 测试方法跑完了的时候，被测代码可能还没跑完

思路 : 
    - 异步代码执行完了再执行assert操作
    - 二是将异步变成同步

### 普通异步方法

#### 方法一:等待异步代码执行完毕：使用CountDownLatch

##### 原理

类似于倒序计数，刚开始设定了一个数字，每次countDown()这个数字减一，await()方法会一直等待，直到这个数字为0。

##### 方法

- countDown() 
- await()  -   阻塞当前线程，直到countDown()被调用了一定的次数，这个次数就是在创建这个CountDownLatch对象时，传入的构造参数。

    其中 await() 还有一个重载方法，可以用来指定你要等待多久

    >    // 等待2秒钟，如果2秒以后，计数是0了，则返回True，否则返回False。
    >    
    >    latch.await(2, TimeUnit.SECONDS);
    
** 例子 **

``` java
CountDownLatch latch = new CountDownLatch(3);
// ...
// 下面这行代码会让当前线程一直停在这里
// 直到latch.countDown()被调用了3次（一般是在其它线程）
latch.await();
```

##### 限制

- 必需有Callback

    countDown()必须可以在测试代码里面写，换句话说，必需有Callback。如果被测的异步方法（比如上面的loadRepos())不是通过Callback的方式来通知结果，而是通过post EventBus的Event来通知外面方法运行的结果，那CountDownLatch是无法解决这个异步方法的单元测试问题的。

- 写起来麻烦

    创建对象、调用countDown()、调用await()都必须手动写，而且还没有通用性


#### 方法二:将异步变成同步

依赖注入

##### 直接new Thread的情况
呃，如果你直接在正式代码里面new Thread()来做异步，那么你的代码是没有办法变成同步的，换成Executor这种方式来做吧。

##### Executor或ExecutorService的情况
如果你的代码是通过Executor或ExecutorService来做异步的，那在测试中把异步变成同步的做法，跟在测试中使用mock对象的方法是一样的，那就是使用依赖注入。在测试代码里面将同步的Executor注入进去。创建同步的Executor对象很简单，以下就是一个同步的Executor：

Executor executor = new Executor() {
    @Override
    public void execute(Runnable command) {
        command.run();
    }
};
当然，你可以使用一个辅助的factory方法来做这件事情。至于怎么样将这个同步的Executor在测试里面替换掉真实异步的那个Executor，就是依赖注入的问题了。具体的做法请参见系列第5篇：依赖注入，将mock方便的用起来，如果你使用了Dagger2的话，请看第六篇：使用dagger2来做依赖注入，以及在单元测试中的应用。

##### AsyncTask
笔者建议是不要使用AsyncTask，这个东西有很多问题，其中之一是它的行为是很难预测的，之二是如果你在Activity里面使用的话，其实这部分代码往往是不应该放在Activity里面的。
不过，如果你实在需要使用AsyncTask，同时又想对这些代码作单元测试的话，建议是使用 AsyncTask#executeOnExecutor()而不是直接使用AsyncTask#execute()，然后通过依赖注入的方式，在测试环境下将同步的Executor注入进去。




### Rxjava 单元测试

- Rx 默认是单线程的,除非你明确的指定线程，否则所有 onNext/onError/onCompleted 以及各个操作函数的调用都是在同一个线程中完成的
- subscribeOn 和 observeOn 分别用来控制 subscription 的调用线程和 接受事件通知（Observer 的 onNext/onError/onCompleted 函数）的线程
- 有些 Observable 内部会使用它们自己创建的线程。例如 Observable.interval 就是异步的。这种情况下，无需指定新的线程。

#### 简单例子

普通写法

```java
@Test
public void testRxjava() throws InterruptedException {
    List<String> WORDS = Arrays.asList(
        "the",
        "quick",
        "brown",
        "fox",
        "jumped",
        "over",
        "the",
        "lazy",
        "dog"
    );

    // 1.用 TestObserver 测试 Rxjava
    TestObserver<String> testObserver = new TestObserver<>();
    Observable<String> observable = Observable.fromIterable(WORDS)
                   .zipWith(Observable.range(1, Integer.MAX_VALUE), (string, index) -> String.format("%2d. %s", index, string));

    observable.subscribeOn(Schedulers.computation())
              .subscribe(testObserver);

    // 2. 等待 testObserver 收到返回
    testObserver.awaitTerminalEvent();

    // 3. 要验证的内容
    testObserver.assertComplete();
    testObserver.assertNoErrors();
    assertThat(testObserver.values()).contains(" 4. fox");
}
```

简单写法

```java
@Test
public void testRxjavaSimpleWay() throws InterruptedException {
    List<String> WORDS = Arrays.asList(
            "the",
            "quick",
            "brown",
            "fox",
            "jumped",
            "over",
            "the",
            "lazy",
            "dog"
    );

    Observable.fromIterable(WORDS)
              .zipWith(Observable.range(1, Integer.MAX_VALUE), (string, index) -> String.format("%2d. %s", index, string))
              .subscribeOn(Schedulers.computation())
              .test()
              .await()
              .assertComplete()
              .assertNoErrors()
              .assertValueAt(4, value -> value.equals(" 5. jumped"));
}
```

#### 测试异常

测试目标代码：

```java
Observable<String> confirmation() {
    Observable<String> delayBeforeCompletion = Observable.<String>empty()
                                                    .delay(200, MILLISECONDS);
    return Observable.just("a")
                     .delay(100, MILLISECONDS)
                     .concatWith(delayBeforeCompletion);
}
```

测试代码:

```java
@Test
public void testTimeOut() throws InterruptedException {

    confirmation().timeout(110, MILLISECONDS)
                  .test()
                  .await()
                  .assertValue("a")
                  .assertError(TimeoutException.class);

}
```


#### TestScheduler

```java
Observable.interval(1, TimeUnit.SECONDS)
          .take(5)
```
Observable 发射一个数据流，需要 5秒 来发射完所有的数据。如果我们使用自动化测试这个代码，则是不是意味着测试代码也要执行 5秒，如果我们有成千上万个这样的测试，测试将消耗很多时间去完成。
解决方案：实际操作中，虽然无法加速系统时钟，但是可以加速一个虚拟的时钟。在 Rx 设计中，考虑到只在 scheduler 中使用时间相关的操作。这样可以用一个虚拟的 TestScheduler 来替代真实的 Scheduler。

##### 方法

- advanceTimeTo：把 TestScheduler 中的时钟前进指定的时间刻度
- advanceTimeBy：在当前时间基础上前进多少
- triggerActions：triggerActions 不会修改时间。只是用来执行当前可以调度的任务

##### 例子

###### advanceTime 例子

测试目标代码：

```java
public class CommonExample {
     public Observable<String> createData(Scheduler scheduler) {
        List<String> WORDS = Arrays.asList(
                "the",
                "quick",
                "brown",
                "fox",
                "jumped",
                "over",
                "the",
                "lazy",
                "dog"
        );

        return Observable.fromIterable(WORDS)
                         .zipWith(Observable.interval(1, SECONDS, scheduler) , (string, index) -> String.format("%2d. %s", index, string));
    }
}
```

测试用例代码：

```java
@Test
public void testScheduler() throws InterruptedException {
    Scheduler scheduler = Schedulers.newThread();

    new CommonExample().createData(scheduler)
                       .test()
                       .await()
                       .assertNoErrors()
                       .assertComplete()
                       .assertValueAt(8, value -> value.equals(" 8. dog"));
}
```

```java
 @Test
    public void testSchedulerByAdvanceTime() throws InterruptedException {
        Scheduler scheduler = new TestScheduler();

        CommonExample commonExample = new CommonExample();
        TestObserver<String> observer = commonExample.createData(scheduler).test();

        observer.assertNoValues()
                .assertNotComplete();

        ((TestScheduler) scheduler).advanceTimeBy(1, SECONDS);

        observer.assertNoErrors()
                .assertValueCount(1)
                .assertValues(" 0. the");

        ((TestScheduler) scheduler).advanceTimeTo(9, SECONDS);

        observer.assertComplete()
                .assertNoErrors()
                .assertValueCount(9)
                .assertValueAt(8, value -> value.equals(" 8. dog"));
    }
```

###### triggerActions 例子

```java
@Test
public void testTriggerActions() {
    TestScheduler s = new TestScheduler();
    s.createWorker().schedule(() -> System.out.println("createWorker  Immediate"));
    s.createWorker().schedule(() -> System.out.println("createWorker    20s"), 20, TimeUnit.SECONDS);
    s.triggerActions();
    System.out.println("Virtual time: " + s.now(TimeUnit.SECONDS));
}
```


#### 配合模拟使用

测试目标代码：

```java
 public Single<List<UserStats>> loadUsers() {
        return service.getTopUsers()
                .flattenAsObservable(UserResponse::items)
                .take(5)
                .flatMapSingle(this::loadUserStats)
                .toList();
    }

    private Single<UserStats> loadUserStats(User user) {
        return service.getBadges(user.id())
                .subscribeOn(Schedulers.io())
                .map(BadgeResponse::items)
                .map(badges -> UserStats.create(user, badges));
    }
```

loadUsers 返回数据顺序不一定，根据 userid 获取 loadUserStats 返回的顺序也不确定，所以测试用例要考虑多种情况
测试用例代码：

- 以下测试用例结果不固定

```java
   @Test
    public void testSubscribe() throws InterruptedException {
        when(stackOverflowService.getTopUsers()).thenReturn(
                just(UserResponse.create(
                        User.create(2, 100, "user 2"),
                        User.create(1, 100, "user 1")
                ))
        );
        when(stackOverflowService.getBadges(anyInt())).thenReturn(
                just(BadgeResponse.create(Badge.create("badge"))));


        userService.loadUsers()
                .test()
                .await()
                .assertNoErrors()
                .assertValue(l -> l.size() == 2)
                .assertValue(l ->
                        Observable.fromIterable(l)
                                .map(UserStats::id)
                                .toList()
                                .blockingGet()
                                .equals(Arrays.asList(1, 2)));
    }
```

这种测试用例可能出现两种情况，顺序可能 user1，user2，也有可能 user2，user1，导致测试结果不准确

- 测试用例要尽可能模拟真实情况，多种情况, 确保测试用的结果是确定的，而不是多变的。

```java
@Test
    public void testSubscribe() throws InterruptedException {
        when(stackOverflowService.getTopUsers())
                .thenReturn(just(UserResponse.create(
                        User.create(1, 100, "user 1"),
                        User.create(2, 100, "user 2")
                )));
        when(stackOverflowService.getBadges(eq(1))).thenReturn(
                just(BadgeResponse.create(Badge.create("badge1")))
                        .delay(2, TimeUnit.SECONDS));
        when(stackOverflowService.getBadges(eq(2))).thenReturn(
                just(BadgeResponse.create(Badge.create("badge2")))
                        .delay(1, TimeUnit.SECONDS));

        userService.loadUsers()
                .test()
                .await()
                .assertNoErrors()
                .assertValue(l -> 
                        Observable.fromIterable(l)
                                .map(UserStats::id)
                                .toList()
                                .blockingGet()
                                .equals(Arrays.asList(2, 1)));
}
```

如果想loadUserStats 的顺序按照 loadUsers传入的顺序输出,可以修改源程序

```java
public Single<List<UserStats>> loadUsers() {
        return service.getTopUsers()
                .flattenAsObservable(UserResponse::items)
                .take(5)
                .concatMap(this::loadUserStats)
                .toList();
    }

    private Observable<UserStats> loadUserStats(User user) {
        return service.getBadges(user.id())
                .subscribeOn(Schedulers.io())
                .map(BadgeResponse::items)
                .map(badges -> UserStats.create(user, badges))
                .toObservable();
    }
```

测试异常情况

测试目标代码：
```java
public Single<List<UserStats>> loadUsers() {
        return service.getTopUsers()
                .flattenAsObservable(UserResponse::items)
                .take(5)
                .concatMap(this::loadUserStats)
                .retry(1)
                .toList();
    }

    private Observable<UserStats> loadUserStats(User user) {
        return service.getBadges(user.id())
                .subscribeOn(Schedulers.io())
                .map(BadgeResponse::items)
                .map(badges -> UserStats.create(user, badges))
                .toObservable();
    }
```

测试用例代码：
```java
@Test public void testErrorOnBadge() throws InterruptedException {
        when(stackOverflowService.getTopUsers()).thenReturn(
                just(UserResponse.create(
                        User.create(1, 200, "user 1"),
                        User.create(2, 100, "user 2")
                ))
        );
        when(stackOverflowService.getBadges(eq(1)))
                .thenThrow(new RuntimeException(":("))
                .thenReturn(
                        just(BadgeResponse.create(Badge.create("badge1")))
                );
        when(stackOverflowService.getBadges(eq(2))).thenReturn(
                just(BadgeResponse.create(Badge.create("badge2")))
        );

        userService.loadUsers()
                .test()
                .await()
                .assertNoErrors()
                .assertValue(l ->
                        Observable.fromIterable(l)
                                .map(UserStats::id)
                                .toList()
                                .blockingGet()
                                .equals(Arrays.asList(1, 2)));
}

 @Test
    public void testErrorOnTopUsers() throws InterruptedException {
        when(stackOverflowService.getTopUsers())
                .thenReturn(Single.fromCallable(new Callable<UserResponse>() {
                    private boolean firstEmitted;

                    @Override
                    public UserResponse call() throws Exception {
                        if (!firstEmitted) {
                            firstEmitted = true;
                            throw new RuntimeException(":(");
                        } else {
                            return UserResponse.create(
                                    User.create(1, 200, "user 1"),
                                    User.create(2, 100, "user 2")
                            );
                        }
                    }
                }));
        when(stackOverflowService.getBadges(eq(1))).thenReturn(
                just(BadgeResponse.create(Badge.create("badge1")))
        );
        when(stackOverflowService.getBadges(eq(2))).thenReturn(
                just(BadgeResponse.create(Badge.create("badge2")))
        );

        userService.loadUsers()
                .test()
                .await()
                .assertNoErrors()
                .assertValue(l ->
                        Observable.fromIterable(l)
                                .map(UserStats::id)
                                .toList()
                                .blockingGet()
                                .equals(Arrays.asList(1, 2)));
    }
```



http://www.infoq.com/cn/articles/Testing-RxJava2
http://chriszou.com/2016/08/06/android-unit-testing-async.html